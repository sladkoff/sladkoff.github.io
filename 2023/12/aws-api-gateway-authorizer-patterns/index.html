<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Introduction AWS API Gateway Authorizers are a powerful tool to secure API Gateway endpoints.
The configuration of Authorizers can be a bit overwhelming at first. There are many options which have an impact on the security, performance and programming model of your API Gateway.
This article is a collection of three patterns that I have identified from my experience with AWS API Gateway Authorizers, from discussions with peers and colleagues and from existing documentation online."><meta name=keywords content=",aws,cloud"><meta name=robots content="noodp"><meta name=theme-color content="#2ecc71"><link rel=canonical href=https://blog.sldk.de/2023/12/aws-api-gateway-authorizer-patterns/><title>AWS API Gateway Authorizer Patterns :: Leonid Koftun — Software Engineer</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=https://blog.sldk.de/main.d7bdd8ee18bfbf4c605488a7e5b1b92cd980dfeed2bdaeab4dd5e931a7a78bc0.css><link rel=stylesheet type=text/css href=https://blog.sldk.de/css/prism.css><link rel=stylesheet type=text/css href=https://blog.sldk.de/css/style.css><meta itemprop=name content="AWS API Gateway Authorizer Patterns"><meta itemprop=description content="Introduction AWS API Gateway Authorizers are a powerful tool to secure API Gateway endpoints.
The configuration of Authorizers can be a bit overwhelming at first. There are many options which have an impact on the security, performance and programming model of your API Gateway.
This article is a collection of three patterns that I have identified from my experience with AWS API Gateway Authorizers, from discussions with peers and colleagues and from existing documentation online."><meta itemprop=datePublished content="2023-12-10T00:00:00+00:00"><meta itemprop=dateModified content="2023-12-10T12:00:05+01:00"><meta itemprop=wordCount content="983"><meta itemprop=image content="https://blog.sldk.de"><meta itemprop=keywords content="aws,cloud,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.sldk.de"><meta name=twitter:title content="AWS API Gateway Authorizer Patterns"><meta name=twitter:description content="Introduction AWS API Gateway Authorizers are a powerful tool to secure API Gateway endpoints.
The configuration of Authorizers can be a bit overwhelming at first. There are many options which have an impact on the security, performance and programming model of your API Gateway.
This article is a collection of three patterns that I have identified from my experience with AWS API Gateway Authorizers, from discussions with peers and colleagues and from existing documentation online."><meta property="article:published_time" content="2023-12-10 00:00:00 +0000 UTC"><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=sldk data-description="Support me on Buy me a coffee!" data-message data-color=#f05f70 data-position=Right data-x_margin=18 data-y_margin=18></script><script data-goatcounter=https://sldk.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body><div class=container><header class=header><span class=header__inner><a href=https://blog.sldk.de/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://blog.sldk.de/about>About</a></li><li><a href=https://blog.sldk.de/posts>Posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>5 minutes</p></div><article><h1 class=post-title><a href=https://blog.sldk.de/2023/12/aws-api-gateway-authorizer-patterns/>AWS API Gateway Authorizer Patterns</a></h1><hr><aside id=toc><div class=toc-title>Table of Contents</div><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#no-authorizer-pattern>No-Authorizer Pattern</a><ul><li><a href=#when-to-use>When to use</a></li></ul></li><li><a href=#cacheable-vs-non-cacheable-authorizers>Cacheable vs Non-Cacheable Authorizers</a><ul><li><a href=#example>Example</a></li></ul></li><li><a href=#binary-authorizer-pattern>Binary Authorizer Pattern</a><ul><li><a href=#when-to-use-1>When to use</a></li><li><a href=#when-to-cache>When to cache</a></li></ul></li><li><a href=#context-authorizer-pattern>Context Authorizer Pattern</a><ul><li><a href=#when-to-use-2>When to use</a></li><li><a href=#when-to-cache-1>When to cache</a></li></ul></li><li><a href=#choosing-the-right-authorizer-pattern>Choosing the right authorizer pattern</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#further-reading-and-mentions>Further reading and mentions</a></li></ul></nav></aside><hr><div class=post-content><h2 id=introduction>Introduction</h2><p>AWS API Gateway Authorizers are a powerful tool to secure API Gateway endpoints.</p><p>The configuration of Authorizers can be a bit overwhelming at first. There are many options which have an impact
on the security, performance and programming model of your API Gateway.</p><p>This article is a collection of three patterns that I have identified from my experience with AWS API Gateway Authorizers,
from discussions with peers and colleagues and from existing documentation online.</p><p>Please note that this is not a comprehensive guide to API Gateway Authorizers. It&rsquo;s a collection of abstract concepts
that can be used to reason about the different patterns:</p><ol><li><a href=#no-authorizer-pattern><strong>No-Authorizer Pattern</strong></a></li><li><a href=#binary-authorizer-pattern><strong>Binary Authorizer Pattern</strong></a></li><li><a href=#context-authorizer-pattern><strong>Context Authorizer Pattern</strong></a></li></ol><p>Note that the naming of the patterns is not official. I made them up to make it easier to talk about them.</p><h2 id=no-authorizer-pattern>No-Authorizer Pattern</h2><p>The first pattern consists of an API Gateway and integration Lambdas in the background.</p><p><img src=https://blog.sldk.de/img/generated/no-authorizer.svg alt=diagram></p><p>There is no authorizer Lambda configured in the API Gateway. All requests to the API Gateway are authorized by default
and forwarded to the backend Lambdas. The Lambdas are responsible for authorization directly.</p><p>In the diagram above, there is an exemplary &ldquo;External User Service&rdquo; that is queried by the backend Lambdas to authorize
the request.</p><h3 id=when-to-use>When to use</h3><ul><li>When there is a only handful of Lambdas to integrate with the API Gateway</li><li>When it&rsquo;s possible to re-use the same authorization code across Lambdas in a maintainable way (same code repository or
shared library)</li><li>When the authorization call does not take a considerable amount of time to execute</li><li>When authorization logic should be testable together with the business logic</li><li>When each invocation should use the up-to-date authorization information</li></ul><h2 id=cacheable-vs-non-cacheable-authorizers>Cacheable vs Non-Cacheable Authorizers</h2><p>Before we dive into the next patterns, let&rsquo;s talk about caching.</p><p>API Gateway Authorizers can be configured to cache the authorization result for a given request for a given amount of
time.
This is useful when the authorization call takes a considerable amount of time to execute and the authorization result
is not expected to change within the cache time.</p><p>Caching the authorization result can significantly improve the response times of the authorizer but it comes with a
trade-off.
The cached authorization result is not updated until the cache expires. This means that the authorization result may not
be in sync with the actual authorization state of the user.</p><p>This needs to be taken into account when choosing the right authorizer pattern.</p><h3 id=example>Example</h3><ol><li>There&rsquo;s a role based authorization system with 2 roles: <code>admin</code> and <code>user</code></li><li>User A has an admin role and requests a resource in our AWS backend</li><li>The authorization result (&ldquo;user A has admin role and is allowed to do admin things&rdquo;) is cached for a given amount of
time</li><li>In the meantime, user A&rsquo;s role is changed to <code>user</code></li><li>User A requests the same resource again where the authorization result is cached => The cached authorization result
is used and user A is allowed to do admin things even though he shouldn&rsquo;t be allowed to</li></ol><h2 id=binary-authorizer-pattern>Binary Authorizer Pattern</h2><p>This pattern consists of an API Gateway, a single authorizer and integration Lambdas.</p><p><img src=https://blog.sldk.de/img/generated/binary-authorizer.svg alt=diagram></p><p>The authorizer is responsible for the authorization based on a binary decision (e.g. &ldquo;does the request contain a valid
token&rdquo;). In the diagram above, an exemplary &ldquo;External User Service&rdquo; is queried by the authorizer to authorize the request.</p><p>Authorized requests are forwarded to backend Lambdas. The Lambdas assume that the requester is authorized to perform the
call and can focus on the business logic.</p><h3 id=when-to-use-1>When to use</h3><ul><li>When separation of concerns between authorization and business logic is needed (code, test, deploy)</li></ul><h3 id=when-to-cache>When to cache</h3><ul><li>When the authorization call takes a considerable amount of time to execute</li><li>When the security requirements allow the use of caching to improve response times of Authorizer and Lambda invocations</li></ul><h2 id=context-authorizer-pattern>Context Authorizer Pattern</h2><p>This pattern consists of an API Gateway, a single authorizer and integration Lambdas.</p><p><img src=https://blog.sldk.de/img/generated/context-authorizer.svg alt=diagram></p><p>The authorizer is responsible for the authorization based on a binary decision (e.g. &ldquo;does the request contain a valid
token&rdquo;)
and for providing the authorization information to the backend Lambdas.</p><p>The Lambdas assume that the requester is authorized to perform the call and receive additional context information to
make more nuanced authorization decisions.</p><p>In the diagram above, an exemplary &ldquo;External User Service&rdquo; is queried by the authorizer to authorize the request and
get the role of the user. The role is then forwarded to the backend Lambdas as context information.</p><h3 id=when-to-use-2>When to use</h3><ul><li>When the authorization conditions are complex and require evaluation on a per-Lambda basis</li><li>When it&rsquo;s possible to re-use the same authorization evaluation code across Lambdas in a maintainable way
(same code repository or shared library)</li></ul><h3 id=when-to-cache-1>When to cache</h3><ul><li>When the authorization call takes a considerable amount of time to execute</li><li>When the security requirements allow the use of caching to improve response times of Authorizer and Lambda invocations</li></ul><h2 id=choosing-the-right-authorizer-pattern>Choosing the right authorizer pattern</h2><p>Here are some questions to ask yourself when choosing the right authorizer pattern.</p><p>Please note that these are based on the identity source being a authorization token.
This does not take into account other identity sources like request parameters where caching behaves differently (I hope
to cover this in a future article).</p><ol><li><p>Does my use-case need strict security requirements?</p><ul><li>Yes:<ul><li>No-Authorizer Pattern</li><li>Non-Cacheable Binary Authorizer Pattern</li><li>Non-Cacheable Context Authorizer Pattern</li></ul></li></ul></li><li><p>Do my authorizer calls take a considerable amount of time to execute?</p><ul><li>Yes:<ul><li>Cacheable Binary Authorizer Pattern</li><li>Cacheable Context Authorizer Pattern</li></ul></li></ul></li><li><p>Do all my Lambdas require the same authorization information?</p><ul><li>Yes:<ul><li>Binary Authorizer Pattern</li></ul></li></ul></li><li><p>Do my Lambdas require different authorization information?</p><ul><li>Yes:<ul><li>Context Authorizer Pattern</li></ul></li></ul></li></ol><h2 id=conclusion>Conclusion</h2><p>We have looked at different patterns for API Gateway Authorizers and learned when to use which pattern.</p><p>There is no one-size-fits-all solution. It&rsquo;s important to understand the trade-offs of each pattern and choose the right
one for your use-case.</p><h2 id=further-reading-and-mentions>Further reading and mentions</h2><ul><li><a href=https://www.linkedin.com/pulse/aws-lambda-authorizer-patterns-caching-harshit-pandey/>AWS Lambda Authorizer Patterns and Caching</a></li><li><a href=https://stackoverflow.com/q/53813947/1510659>API Gateway Authorizer and Logout (Performance/Security Considerations)</a></li></ul></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://blog.sldk.de/tags/aws/>aws</a></span>
<span class=tag><a href=https://blog.sldk.de/tags/cloud/>cloud</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>983 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2023-12-10 00:00 +0000
(Last updated: 2023-12-10 11:00 +0000)</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-git-commit"><circle cx="12" cy="12" r="4"/><line x1="1.05" y1="12" x2="7" y2="12"/><line x1="17.01" y1="12" x2="22.96" y2="12"/></svg><a href=https://github.com/sladkoff/sladkoff.github.io/commit/a93fd29d7d61e3f3985f8fbd31206fe60bd2a910 target=_blank rel=noopener>a93fd29</a>
@ 2023-12-10</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read More</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://blog.sldk.de/2022/05/e2e-email-testing-with-temp-mail/><span class=button__text>E2E email testing with temp-mail</span>
<span class=button__icon>→</span></a></span></div></div><div id=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"blog-sldk-de"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2023</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span><span><a href=https://blog.sldk.de/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://github.com/rhazdon>Djordje Atlialp</a></span></div></div></footer></div><script type=text/javascript src=https://blog.sldk.de/bundle.min.af435e44374f1e99a669ea8cd5bb9a2fceed80588941a451bfddb66b86a67c9f40b0f417e9543a763f809aa7e9300d7b1d69bf99615810ba02ac70396d50fad5.js integrity="sha512-r0NeRDdPHpmmaeqM1buaL87tgFiJQaRRv922a4amfJ9AsPQX6VQ6dj+AmqfpMA17HWm/mWFYELoCrHA5bVD61Q=="></script><script src=https://blog.sldk.de/js/prism.js></script></body></html>